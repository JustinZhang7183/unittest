package com.justin.unittest.junit5.timeout;

import java.util.concurrent.TimeUnit;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;

/**
 * Description: the sample of time out test.
 * <p>
 * you can also declare the @Timeout annotation at the class level
 * but it's not applied to lifecycle methods.
 * </p>
 * <p>
 * declaring @Timeout on a @TestFactory method checks that factory method
 * returns within the specified duration but does not verify the execution
 * of each individual DynamicTest generated by the factory.
 * </p>
 * <p>
 * Thread mode:
 * SAME_THREAD(execute in main thread, interrupted from another thread)
 * SEPARATE_THREAD(execute in a separate thread)
 * INFERRED(it depends on the configuration in junit-platform.properties)
 * if don't config, default is SAME_THREAD.
 * </p>
 * <p>
 * If you need more control over polling intervals and greater flexibility with asynchronous tests,
 * consider using a dedicated library such as Awaitility.
 * </p>
 *
 * @author Justin_Zhang
 * @date 11/9/2022 13:22
 */
public class TimeoutTest {
  @BeforeEach
  @Timeout(5)
  void setUp() {
    // fails if execution time exceeds 5 seconds
  }

  @Test
  @Disabled("just for demonstrate")
  @Timeout(value = 500, unit = TimeUnit.MILLISECONDS,
      threadMode = Timeout.ThreadMode.SAME_THREAD)
  void failsIfExecutionTimeExceeds500Milliseconds() throws InterruptedException {
    // if there is a sleep status, fails if execution time exceeds 500 milliseconds
    TimeUnit.SECONDS.sleep(2);

    // if there is a while true, it doesn't fail
    // while (true) {
    // }
  }

  @Test
  @Disabled("just for demonstrate")
  @Timeout(value = 500, unit = TimeUnit.MILLISECONDS,
      threadMode = Timeout.ThreadMode.SEPARATE_THREAD)
  void failsIfExecutionTimeExceeds500MillisecondsInSeparateThread() {
    // fails if execution time exceeds 500 milliseconds,
    // the test code is executed in a separate thread
    while (true) {
    }
  }

  @Test
  @Disabled("just for demonstrate")
  @Timeout(2)
  void pollUntil() throws InterruptedException {
    while (asynchronousResultNotAvailable()) {
      // sleep 200ms : custom poll interval, if don't sleep it won't stop.
      Thread.sleep(200);
    }
    // obtain the asynchronous result and carry out assertions.
  }

  private boolean asynchronousResultNotAvailable() {
    return true;
  }

}
